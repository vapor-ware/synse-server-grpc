// Code generated by protoc-gen-go. DO NOT EDIT.
// source: synse.proto

/*
Package synse is a generated protocol buffer package.

It is generated from these files:
	synse.proto

It has these top-level messages:
	Bounds
	DeviceFilter
	Empty
	Status
	PluginHealth
	HealthCheck
	DeviceCapability
	Metadata
	VersionInfo
	Reading
	DeviceReading
	WriteInfo
	WriteData
	WriteResponse
	TransactionFilter
	Transactions
	Device
	Location
	Output
	Unit
*/
package synse

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PluginHealth_Status int32

const (
	PluginHealth_UNKNOWN            PluginHealth_Status = 0
	PluginHealth_OK                 PluginHealth_Status = 1
	PluginHealth_PARTIALLY_DEGRADED PluginHealth_Status = 3
	PluginHealth_FAILING            PluginHealth_Status = 4
)

var PluginHealth_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "OK",
	3: "PARTIALLY_DEGRADED",
	4: "FAILING",
}
var PluginHealth_Status_value = map[string]int32{
	"UNKNOWN":            0,
	"OK":                 1,
	"PARTIALLY_DEGRADED": 3,
	"FAILING":            4,
}

func (x PluginHealth_Status) String() string {
	return proto.EnumName(PluginHealth_Status_name, int32(x))
}
func (PluginHealth_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type WriteResponse_WriteStatus int32

const (
	WriteResponse_UNKNOWN WriteResponse_WriteStatus = 0
	WriteResponse_PENDING WriteResponse_WriteStatus = 1
	WriteResponse_WRITING WriteResponse_WriteStatus = 2
	WriteResponse_DONE    WriteResponse_WriteStatus = 3
)

var WriteResponse_WriteStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "WRITING",
	3: "DONE",
}
var WriteResponse_WriteStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"PENDING": 1,
	"WRITING": 2,
	"DONE":    3,
}

func (x WriteResponse_WriteStatus) String() string {
	return proto.EnumName(WriteResponse_WriteStatus_name, int32(x))
}
func (WriteResponse_WriteStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

type WriteResponse_WriteState int32

const (
	WriteResponse_OK    WriteResponse_WriteState = 0
	WriteResponse_ERROR WriteResponse_WriteState = 1
)

var WriteResponse_WriteState_name = map[int32]string{
	0: "OK",
	1: "ERROR",
}
var WriteResponse_WriteState_value = map[string]int32{
	"OK":    0,
	"ERROR": 1,
}

func (x WriteResponse_WriteState) String() string {
	return proto.EnumName(WriteResponse_WriteState_name, int32(x))
}
func (WriteResponse_WriteState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 1} }

// Bounds is a message that allow you to specify bounding timestamps to
// the ReadCached rpc route. If no bounds are specified, all of the cached
// data is returned.
type Bounds struct {
	// An RFC3339-formatted timestamp which specifies the beginning of
	// the time bound. If not specified, there is no starting bound.
	Start string `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	// An RFC3339-formatted timestamp which specifies the ending of the
	// time bound. If not specified, there is no ending bound.
	End string `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *Bounds) Reset()                    { *m = Bounds{} }
func (m *Bounds) String() string            { return proto.CompactTextString(m) }
func (*Bounds) ProtoMessage()               {}
func (*Bounds) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Bounds) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *Bounds) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

// DeviceFilter is a message that specifies the routing information for
// a device. This can also be used as a filter for partial routing info
// by only specifying the rack or the rack+board.
type DeviceFilter struct {
	// The rack identifier.
	Rack string `protobuf:"bytes,1,opt,name=rack" json:"rack,omitempty"`
	// The board identifier.
	Board string `protobuf:"bytes,2,opt,name=board" json:"board,omitempty"`
	// The device identifier.
	Device string `protobuf:"bytes,3,opt,name=device" json:"device,omitempty"`
}

func (m *DeviceFilter) Reset()                    { *m = DeviceFilter{} }
func (m *DeviceFilter) String() string            { return proto.CompactTextString(m) }
func (*DeviceFilter) ProtoMessage()               {}
func (*DeviceFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DeviceFilter) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *DeviceFilter) GetBoard() string {
	if m != nil {
		return m.Board
	}
	return ""
}

func (m *DeviceFilter) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

// Empty is a message that contains no data.
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Status is the response of the `Test` rpc call. In general, it should
// always return with the 'ok' field being true.
type Status struct {
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Status) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

// PluginHealth is the response to the `Health` rpc call. It provides a
// health status summarizing the plugin's health, as well as a list of the
// `HealthCheck`s which make up that status.
type PluginHealth struct {
	// The time that the health was checked.
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The overall health status.
	Status PluginHealth_Status `protobuf:"varint,2,opt,name=status,enum=synse.PluginHealth_Status" json:"status,omitempty"`
	// All the health checks of the plugin that make up the overall health.
	Checks []*HealthCheck `protobuf:"bytes,3,rep,name=checks" json:"checks,omitempty"`
}

func (m *PluginHealth) Reset()                    { *m = PluginHealth{} }
func (m *PluginHealth) String() string            { return proto.CompactTextString(m) }
func (*PluginHealth) ProtoMessage()               {}
func (*PluginHealth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PluginHealth) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *PluginHealth) GetStatus() PluginHealth_Status {
	if m != nil {
		return m.Status
	}
	return PluginHealth_UNKNOWN
}

func (m *PluginHealth) GetChecks() []*HealthCheck {
	if m != nil {
		return m.Checks
	}
	return nil
}

// HealthCheck is an individual health metric that makes up the plugin health.
type HealthCheck struct {
	// The name of the health check.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The status of the health check.
	Status PluginHealth_Status `protobuf:"varint,2,opt,name=status,enum=synse.PluginHealth_Status" json:"status,omitempty"`
	// Any additional info associated with the health check.
	Message string `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	// The time at which the health check was completed.
	Timestamp string `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
	// The type of the health check. These are left as arbitrary strings
	// instead of enums to make it easier to support new types of health
	// checks in the future, without having to update the GRPC API.
	Type string `protobuf:"bytes,5,opt,name=type" json:"type,omitempty"`
}

func (m *HealthCheck) Reset()                    { *m = HealthCheck{} }
func (m *HealthCheck) String() string            { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()               {}
func (*HealthCheck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *HealthCheck) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HealthCheck) GetStatus() PluginHealth_Status {
	if m != nil {
		return m.Status
	}
	return PluginHealth_UNKNOWN
}

func (m *HealthCheck) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *HealthCheck) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *HealthCheck) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// DeviceCapability identifies a device kind and the potential kinds of readings
// that it supports.
type DeviceCapability struct {
	// The kind/type of the device.
	Kind string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	// The outputs that the device supports.
	Outputs []string `protobuf:"bytes,2,rep,name=outputs" json:"outputs,omitempty"`
}

func (m *DeviceCapability) Reset()                    { *m = DeviceCapability{} }
func (m *DeviceCapability) String() string            { return proto.CompactTextString(m) }
func (*DeviceCapability) ProtoMessage()               {}
func (*DeviceCapability) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DeviceCapability) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *DeviceCapability) GetOutputs() []string {
	if m != nil {
		return m.Outputs
	}
	return nil
}

// Metadata is the response to the `Metainfo` rpc call.
type Metadata struct {
	Name        string       `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Maintainer  string       `protobuf:"bytes,2,opt,name=maintainer" json:"maintainer,omitempty"`
	Tag         string       `protobuf:"bytes,3,opt,name=tag" json:"tag,omitempty"`
	Description string       `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	Vcs         string       `protobuf:"bytes,5,opt,name=vcs" json:"vcs,omitempty"`
	Version     *VersionInfo `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Metadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Metadata) GetMaintainer() string {
	if m != nil {
		return m.Maintainer
	}
	return ""
}

func (m *Metadata) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *Metadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Metadata) GetVcs() string {
	if m != nil {
		return m.Vcs
	}
	return ""
}

func (m *Metadata) GetVersion() *VersionInfo {
	if m != nil {
		return m.Version
	}
	return nil
}

// VersionInfo is the response to the `Version` rpc call.
type VersionInfo struct {
	PluginVersion string `protobuf:"bytes,1,opt,name=pluginVersion" json:"pluginVersion,omitempty"`
	SdkVersion    string `protobuf:"bytes,2,opt,name=sdkVersion" json:"sdkVersion,omitempty"`
	BuildDate     string `protobuf:"bytes,3,opt,name=buildDate" json:"buildDate,omitempty"`
	GitCommit     string `protobuf:"bytes,4,opt,name=gitCommit" json:"gitCommit,omitempty"`
	GitTag        string `protobuf:"bytes,5,opt,name=gitTag" json:"gitTag,omitempty"`
	Arch          string `protobuf:"bytes,6,opt,name=arch" json:"arch,omitempty"`
	Os            string `protobuf:"bytes,7,opt,name=os" json:"os,omitempty"`
}

func (m *VersionInfo) Reset()                    { *m = VersionInfo{} }
func (m *VersionInfo) String() string            { return proto.CompactTextString(m) }
func (*VersionInfo) ProtoMessage()               {}
func (*VersionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *VersionInfo) GetPluginVersion() string {
	if m != nil {
		return m.PluginVersion
	}
	return ""
}

func (m *VersionInfo) GetSdkVersion() string {
	if m != nil {
		return m.SdkVersion
	}
	return ""
}

func (m *VersionInfo) GetBuildDate() string {
	if m != nil {
		return m.BuildDate
	}
	return ""
}

func (m *VersionInfo) GetGitCommit() string {
	if m != nil {
		return m.GitCommit
	}
	return ""
}

func (m *VersionInfo) GetGitTag() string {
	if m != nil {
		return m.GitTag
	}
	return ""
}

func (m *VersionInfo) GetArch() string {
	if m != nil {
		return m.Arch
	}
	return ""
}

func (m *VersionInfo) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

// Reading is the response to the `Read` rpc call.
type Reading struct {
	// The time which the reading was taken.
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The type of reading.
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// Any info associated with the reading.
	Info string `protobuf:"bytes,3,opt,name=info" json:"info,omitempty"`
	// The unit of the reading.
	Unit *Unit `protobuf:"bytes,4,opt,name=unit" json:"unit,omitempty"`
	// The value of the reading.
	//
	// Types that are valid to be assigned to Value:
	//	*Reading_StringValue
	//	*Reading_BoolValue
	//	*Reading_Float32Value
	//	*Reading_Float64Value
	//	*Reading_Int32Value
	//	*Reading_Int64Value
	//	*Reading_BytesValue
	//	*Reading_Uint32Value
	//	*Reading_Uint64Value
	Value isReading_Value `protobuf_oneof:"value"`
}

func (m *Reading) Reset()                    { *m = Reading{} }
func (m *Reading) String() string            { return proto.CompactTextString(m) }
func (*Reading) ProtoMessage()               {}
func (*Reading) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isReading_Value interface {
	isReading_Value()
}

type Reading_StringValue struct {
	StringValue string `protobuf:"bytes,5,opt,name=string_value,json=stringValue,oneof"`
}
type Reading_BoolValue struct {
	BoolValue bool `protobuf:"varint,6,opt,name=bool_value,json=boolValue,oneof"`
}
type Reading_Float32Value struct {
	Float32Value float32 `protobuf:"fixed32,7,opt,name=float32_value,json=float32Value,oneof"`
}
type Reading_Float64Value struct {
	Float64Value float64 `protobuf:"fixed64,8,opt,name=float64_value,json=float64Value,oneof"`
}
type Reading_Int32Value struct {
	Int32Value int32 `protobuf:"varint,9,opt,name=int32_value,json=int32Value,oneof"`
}
type Reading_Int64Value struct {
	Int64Value int64 `protobuf:"varint,10,opt,name=int64_value,json=int64Value,oneof"`
}
type Reading_BytesValue struct {
	BytesValue []byte `protobuf:"bytes,11,opt,name=bytes_value,json=bytesValue,proto3,oneof"`
}
type Reading_Uint32Value struct {
	Uint32Value uint32 `protobuf:"varint,12,opt,name=uint32_value,json=uint32Value,oneof"`
}
type Reading_Uint64Value struct {
	Uint64Value uint64 `protobuf:"varint,13,opt,name=uint64_value,json=uint64Value,oneof"`
}

func (*Reading_StringValue) isReading_Value()  {}
func (*Reading_BoolValue) isReading_Value()    {}
func (*Reading_Float32Value) isReading_Value() {}
func (*Reading_Float64Value) isReading_Value() {}
func (*Reading_Int32Value) isReading_Value()   {}
func (*Reading_Int64Value) isReading_Value()   {}
func (*Reading_BytesValue) isReading_Value()   {}
func (*Reading_Uint32Value) isReading_Value()  {}
func (*Reading_Uint64Value) isReading_Value()  {}

func (m *Reading) GetValue() isReading_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Reading) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Reading) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Reading) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *Reading) GetUnit() *Unit {
	if m != nil {
		return m.Unit
	}
	return nil
}

func (m *Reading) GetStringValue() string {
	if x, ok := m.GetValue().(*Reading_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Reading) GetBoolValue() bool {
	if x, ok := m.GetValue().(*Reading_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *Reading) GetFloat32Value() float32 {
	if x, ok := m.GetValue().(*Reading_Float32Value); ok {
		return x.Float32Value
	}
	return 0
}

func (m *Reading) GetFloat64Value() float64 {
	if x, ok := m.GetValue().(*Reading_Float64Value); ok {
		return x.Float64Value
	}
	return 0
}

func (m *Reading) GetInt32Value() int32 {
	if x, ok := m.GetValue().(*Reading_Int32Value); ok {
		return x.Int32Value
	}
	return 0
}

func (m *Reading) GetInt64Value() int64 {
	if x, ok := m.GetValue().(*Reading_Int64Value); ok {
		return x.Int64Value
	}
	return 0
}

func (m *Reading) GetBytesValue() []byte {
	if x, ok := m.GetValue().(*Reading_BytesValue); ok {
		return x.BytesValue
	}
	return nil
}

func (m *Reading) GetUint32Value() uint32 {
	if x, ok := m.GetValue().(*Reading_Uint32Value); ok {
		return x.Uint32Value
	}
	return 0
}

func (m *Reading) GetUint64Value() uint64 {
	if x, ok := m.GetValue().(*Reading_Uint64Value); ok {
		return x.Uint64Value
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Reading) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Reading_OneofMarshaler, _Reading_OneofUnmarshaler, _Reading_OneofSizer, []interface{}{
		(*Reading_StringValue)(nil),
		(*Reading_BoolValue)(nil),
		(*Reading_Float32Value)(nil),
		(*Reading_Float64Value)(nil),
		(*Reading_Int32Value)(nil),
		(*Reading_Int64Value)(nil),
		(*Reading_BytesValue)(nil),
		(*Reading_Uint32Value)(nil),
		(*Reading_Uint64Value)(nil),
	}
}

func _Reading_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Reading)
	// value
	switch x := m.Value.(type) {
	case *Reading_StringValue:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StringValue)
	case *Reading_BoolValue:
		t := uint64(0)
		if x.BoolValue {
			t = 1
		}
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Reading_Float32Value:
		b.EncodeVarint(7<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(math.Float32bits(x.Float32Value)))
	case *Reading_Float64Value:
		b.EncodeVarint(8<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.Float64Value))
	case *Reading_Int32Value:
		b.EncodeVarint(9<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int32Value))
	case *Reading_Int64Value:
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int64Value))
	case *Reading_BytesValue:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.BytesValue)
	case *Reading_Uint32Value:
		b.EncodeVarint(12<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Uint32Value))
	case *Reading_Uint64Value:
		b.EncodeVarint(13<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Uint64Value))
	case nil:
	default:
		return fmt.Errorf("Reading.Value has unexpected type %T", x)
	}
	return nil
}

func _Reading_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Reading)
	switch tag {
	case 5: // value.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Reading_StringValue{x}
		return true, err
	case 6: // value.bool_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Reading_BoolValue{x != 0}
		return true, err
	case 7: // value.float32_value
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Value = &Reading_Float32Value{math.Float32frombits(uint32(x))}
		return true, err
	case 8: // value.float64_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Reading_Float64Value{math.Float64frombits(x)}
		return true, err
	case 9: // value.int32_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Reading_Int32Value{int32(x)}
		return true, err
	case 10: // value.int64_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Reading_Int64Value{int64(x)}
		return true, err
	case 11: // value.bytes_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Value = &Reading_BytesValue{x}
		return true, err
	case 12: // value.uint32_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Reading_Uint32Value{uint32(x)}
		return true, err
	case 13: // value.uint64_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Reading_Uint64Value{x}
		return true, err
	default:
		return false, nil
	}
}

func _Reading_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Reading)
	// value
	switch x := m.Value.(type) {
	case *Reading_StringValue:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringValue)))
		n += len(x.StringValue)
	case *Reading_BoolValue:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case *Reading_Float32Value:
		n += proto.SizeVarint(7<<3 | proto.WireFixed32)
		n += 4
	case *Reading_Float64Value:
		n += proto.SizeVarint(8<<3 | proto.WireFixed64)
		n += 8
	case *Reading_Int32Value:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int32Value))
	case *Reading_Int64Value:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int64Value))
	case *Reading_BytesValue:
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.BytesValue)))
		n += len(x.BytesValue)
	case *Reading_Uint32Value:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Uint32Value))
	case *Reading_Uint64Value:
		n += proto.SizeVarint(13<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Uint64Value))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DeviceReading is a wrapper around a Reading which associates that
// reading with its originating device by providing the device routing
// information (rack, board, and device id).
type DeviceReading struct {
	// The rack id associated with the reading.
	Rack string `protobuf:"bytes,1,opt,name=rack" json:"rack,omitempty"`
	// The board id associated with the reading.
	Board string `protobuf:"bytes,2,opt,name=board" json:"board,omitempty"`
	// The device id associated with the reading.
	Device string `protobuf:"bytes,3,opt,name=device" json:"device,omitempty"`
	// The reading itself.
	Reading *Reading `protobuf:"bytes,4,opt,name=reading" json:"reading,omitempty"`
}

func (m *DeviceReading) Reset()                    { *m = DeviceReading{} }
func (m *DeviceReading) String() string            { return proto.CompactTextString(m) }
func (*DeviceReading) ProtoMessage()               {}
func (*DeviceReading) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeviceReading) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *DeviceReading) GetBoard() string {
	if m != nil {
		return m.Board
	}
	return ""
}

func (m *DeviceReading) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *DeviceReading) GetReading() *Reading {
	if m != nil {
		return m.Reading
	}
	return nil
}

// WriteInfo is the request message for the `Write` rpc call. It specifies a
// filter for the device to write to, as well as actions/data for the write.
type WriteInfo struct {
	// The specifier for the device to write to.
	DeviceFilter *DeviceFilter `protobuf:"bytes,1,opt,name=deviceFilter" json:"deviceFilter,omitempty"`
	// The data to write to the device.
	Data []*WriteData `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
}

func (m *WriteInfo) Reset()                    { *m = WriteInfo{} }
func (m *WriteInfo) String() string            { return proto.CompactTextString(m) }
func (*WriteInfo) ProtoMessage()               {}
func (*WriteInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *WriteInfo) GetDeviceFilter() *DeviceFilter {
	if m != nil {
		return m.DeviceFilter
	}
	return nil
}

func (m *WriteInfo) GetData() []*WriteData {
	if m != nil {
		return m.Data
	}
	return nil
}

// WriteData is the data that gets written on a `Write` rpc call.
type WriteData struct {
	// The action string for the device write.
	Action string `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	// The data to write.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteData) Reset()                    { *m = WriteData{} }
func (m *WriteData) String() string            { return proto.CompactTextString(m) }
func (*WriteData) ProtoMessage()               {}
func (*WriteData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *WriteData) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *WriteData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// WriteResponse is the response for a `Transaction` rpc call. It gives the
// status of the transaction. Transactions correspond with write requests.
// Since writes are performed asynchronously, the transaction id is used to
// track the progress of that transaction.
type WriteResponse struct {
	// The id of the write transaction.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The time at which the write transaction was created.
	Created string `protobuf:"bytes,2,opt,name=created" json:"created,omitempty"`
	// The time at which the write transaction state/status was last updated.
	Updated string `protobuf:"bytes,3,opt,name=updated" json:"updated,omitempty"`
	// The status of the transaction. This describes what stage of processing
	// the transaction is at.
	Status WriteResponse_WriteStatus `protobuf:"varint,4,opt,name=status,enum=synse.WriteResponse_WriteStatus" json:"status,omitempty"`
	// The state of the transaction. This describes the so called "health"
	// of the transaction.
	State WriteResponse_WriteState `protobuf:"varint,5,opt,name=state,enum=synse.WriteResponse_WriteState" json:"state,omitempty"`
	// The message field will be used to specify any context information
	// when the state is ERROR. If the state is OK, this field will
	// remain empty.
	Message string `protobuf:"bytes,6,opt,name=message" json:"message,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *WriteResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *WriteResponse) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *WriteResponse) GetUpdated() string {
	if m != nil {
		return m.Updated
	}
	return ""
}

func (m *WriteResponse) GetStatus() WriteResponse_WriteStatus {
	if m != nil {
		return m.Status
	}
	return WriteResponse_UNKNOWN
}

func (m *WriteResponse) GetState() WriteResponse_WriteState {
	if m != nil {
		return m.State
	}
	return WriteResponse_OK
}

func (m *WriteResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// TransactionFilter is a filter for transaction checks. If its id field is
// set, the plugin will only check the state for that transaction. If the id
// field is empty, the plugin will return the state for all active transactions.
type TransactionFilter struct {
	// The id of the transaction to check.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *TransactionFilter) Reset()                    { *m = TransactionFilter{} }
func (m *TransactionFilter) String() string            { return proto.CompactTextString(m) }
func (*TransactionFilter) ProtoMessage()               {}
func (*TransactionFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *TransactionFilter) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Transactions specifies the asynchronous transactions for each of the writes
// for a `Write` rpc call. Each transaction identifies a single write action
// with a unique transaction id and context to help identify which transaction
// that id corresponds to.
//
// The transaction id can later be passed back to the `Transaction` rpc call
// to get the status of that write.
type Transactions struct {
	// A map where the key is the transaction id for a `WriteData` within the
	// `WriteInfo`, and the value is that same `WriteData`, provided as context.
	Transactions map[string]*WriteData `protobuf:"bytes,1,rep,name=transactions" json:"transactions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Transactions) Reset()                    { *m = Transactions{} }
func (m *Transactions) String() string            { return proto.CompactTextString(m) }
func (*Transactions) ProtoMessage()               {}
func (*Transactions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Transactions) GetTransactions() map[string]*WriteData {
	if m != nil {
		return m.Transactions
	}
	return nil
}

// Device is the response to the `Devices` rpc call. It provides all of the
// info that synse gets to describe a device. This is used by Synse Server for
// its 'scan' and 'info' endpoints.
type Device struct {
	// The time at which the device info was gathered.
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The unique id for the device.
	Uid string `protobuf:"bytes,2,opt,name=uid" json:"uid,omitempty"`
	// The device kind. This can also be thought of as 'device type'.
	Kind string `protobuf:"bytes,3,opt,name=kind" json:"kind,omitempty"`
	// Any metadata associated with the device.
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The name of the plugin that the device is managed by.
	Plugin string `protobuf:"bytes,5,opt,name=plugin" json:"plugin,omitempty"`
	// Any additional information specified for the device.
	Info string `protobuf:"bytes,6,opt,name=info" json:"info,omitempty"`
	// The location of the device, as specified by rack and board
	// identifiers.
	Location *Location `protobuf:"bytes,7,opt,name=location" json:"location,omitempty"`
	// The one based sort ordinal for a device in the scan. Zero (default)
	// for don't care.
	SortOrdinal int32 `protobuf:"varint,8,opt,name=sortOrdinal" json:"sortOrdinal,omitempty"`
	// The reading output of the device. This specifies all of the
	// outputs a device can generate when read. Many devices will have
	// a single output, but some devices (e.g. a humidity sensor) could
	// return multiple data points from a single reading (e.g.
	// temperature and humidity).
	Output []*Output `protobuf:"bytes,9,rep,name=output" json:"output,omitempty"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Device) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Device) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Device) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *Device) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Device) GetPlugin() string {
	if m != nil {
		return m.Plugin
	}
	return ""
}

func (m *Device) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *Device) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Device) GetSortOrdinal() int32 {
	if m != nil {
		return m.SortOrdinal
	}
	return 0
}

func (m *Device) GetOutput() []*Output {
	if m != nil {
		return m.Output
	}
	return nil
}

// Location is the location specification for a device.
type Location struct {
	// The rack which the device belongs to.
	Rack string `protobuf:"bytes,1,opt,name=rack" json:"rack,omitempty"`
	// The board which the device belongs to.
	Board string `protobuf:"bytes,2,opt,name=board" json:"board,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Location) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *Location) GetBoard() string {
	if m != nil {
		return m.Board
	}
	return ""
}

// Output is the specification for one of a device's reading outputs.
type Output struct {
	// The name of the output. This is namespaced.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The type of the output. This is the last element of the namespace.
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// The decimal precision of the output. This is ignored if the output
	// dataType is not a float.
	Precision int32 `protobuf:"varint,3,opt,name=precision" json:"precision,omitempty"`
	// The scaling factor to multiply the reading result by. This can be
	// positive or negative, whole or decimal.
	ScalingFactor float64 `protobuf:"fixed64,4,opt,name=scalingFactor" json:"scalingFactor,omitempty"`
	// The unit of measure for the reading.
	Unit *Unit `protobuf:"bytes,5,opt,name=unit" json:"unit,omitempty"`
}

func (m *Output) Reset()                    { *m = Output{} }
func (m *Output) String() string            { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()               {}
func (*Output) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Output) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Output) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Output) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Output) GetScalingFactor() float64 {
	if m != nil {
		return m.ScalingFactor
	}
	return 0
}

func (m *Output) GetUnit() *Unit {
	if m != nil {
		return m.Unit
	}
	return nil
}

// Unit is the unit specification for a reading output.
type Unit struct {
	// The full name of the unit, e.g. "degrees celsius".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The symbol for the unit, e.g. "C".
	Symbol string `protobuf:"bytes,2,opt,name=symbol" json:"symbol,omitempty"`
}

func (m *Unit) Reset()                    { *m = Unit{} }
func (m *Unit) String() string            { return proto.CompactTextString(m) }
func (*Unit) ProtoMessage()               {}
func (*Unit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Unit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Unit) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func init() {
	proto.RegisterType((*Bounds)(nil), "synse.Bounds")
	proto.RegisterType((*DeviceFilter)(nil), "synse.DeviceFilter")
	proto.RegisterType((*Empty)(nil), "synse.Empty")
	proto.RegisterType((*Status)(nil), "synse.Status")
	proto.RegisterType((*PluginHealth)(nil), "synse.PluginHealth")
	proto.RegisterType((*HealthCheck)(nil), "synse.HealthCheck")
	proto.RegisterType((*DeviceCapability)(nil), "synse.DeviceCapability")
	proto.RegisterType((*Metadata)(nil), "synse.Metadata")
	proto.RegisterType((*VersionInfo)(nil), "synse.VersionInfo")
	proto.RegisterType((*Reading)(nil), "synse.Reading")
	proto.RegisterType((*DeviceReading)(nil), "synse.DeviceReading")
	proto.RegisterType((*WriteInfo)(nil), "synse.WriteInfo")
	proto.RegisterType((*WriteData)(nil), "synse.WriteData")
	proto.RegisterType((*WriteResponse)(nil), "synse.WriteResponse")
	proto.RegisterType((*TransactionFilter)(nil), "synse.TransactionFilter")
	proto.RegisterType((*Transactions)(nil), "synse.Transactions")
	proto.RegisterType((*Device)(nil), "synse.Device")
	proto.RegisterType((*Location)(nil), "synse.Location")
	proto.RegisterType((*Output)(nil), "synse.Output")
	proto.RegisterType((*Unit)(nil), "synse.Unit")
	proto.RegisterEnum("synse.PluginHealth_Status", PluginHealth_Status_name, PluginHealth_Status_value)
	proto.RegisterEnum("synse.WriteResponse_WriteStatus", WriteResponse_WriteStatus_name, WriteResponse_WriteStatus_value)
	proto.RegisterEnum("synse.WriteResponse_WriteState", WriteResponse_WriteState_name, WriteResponse_WriteState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Plugin service

type PluginClient interface {
	// Test returns the status of the plugin. This call is intended to
	// be used in order to check if a plugin is reachable. The status
	// returned here designates plugin reachability, not plugin health.
	Test(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	// Version returns the version info for the plugin. This is not used
	// by Synse Server, but can be used by the CLI/manual plugin interaction.
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionInfo, error)
	// Health returns the health status of a plugin.
	Health(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginHealth, error)
	// Metainfo gets the metainfo for the plugin. This info provides details
	// about the plugin itself.
	Metainfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Metadata, error)
	// Capabilities returns the collection of capabilities that a plugin
	// exposes. More specifically, this means types of devices supported
	// and the readings supported for each of those devices.
	Capabilities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Plugin_CapabilitiesClient, error)
	// Devices gets info for all of the devices that the plugin manages.
	// This rpc call is the plugin's equivalent to a Synse Server scan.
	Devices(ctx context.Context, in *DeviceFilter, opts ...grpc.CallOption) (Plugin_DevicesClient, error)
	// Read returns the reading data for the specified device.
	Read(ctx context.Context, in *DeviceFilter, opts ...grpc.CallOption) (Plugin_ReadClient, error)
	// ReadCached returns the reading data that is cached by the plugin.
	// If caching is not enabled on the plugin, this will just return the
	// current readings.
	ReadCached(ctx context.Context, in *Bounds, opts ...grpc.CallOption) (Plugin_ReadCachedClient, error)
	// Write issues an asynchronous write command to the specified device.
	Write(ctx context.Context, in *WriteInfo, opts ...grpc.CallOption) (*Transactions, error)
	// Transactiong gets the state/status of an asynchronous write transaction.
	Transaction(ctx context.Context, in *TransactionFilter, opts ...grpc.CallOption) (Plugin_TransactionClient, error)
}

type pluginClient struct {
	cc *grpc.ClientConn
}

func NewPluginClient(cc *grpc.ClientConn) PluginClient {
	return &pluginClient{cc}
}

func (c *pluginClient) Test(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/synse.Plugin/Test", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionInfo, error) {
	out := new(VersionInfo)
	err := grpc.Invoke(ctx, "/synse.Plugin/Version", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Health(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginHealth, error) {
	out := new(PluginHealth)
	err := grpc.Invoke(ctx, "/synse.Plugin/Health", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Metainfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Metadata, error) {
	out := new(Metadata)
	err := grpc.Invoke(ctx, "/synse.Plugin/Metainfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Capabilities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Plugin_CapabilitiesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Plugin_serviceDesc.Streams[0], c.cc, "/synse.Plugin/Capabilities", opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginCapabilitiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Plugin_CapabilitiesClient interface {
	Recv() (*DeviceCapability, error)
	grpc.ClientStream
}

type pluginCapabilitiesClient struct {
	grpc.ClientStream
}

func (x *pluginCapabilitiesClient) Recv() (*DeviceCapability, error) {
	m := new(DeviceCapability)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pluginClient) Devices(ctx context.Context, in *DeviceFilter, opts ...grpc.CallOption) (Plugin_DevicesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Plugin_serviceDesc.Streams[1], c.cc, "/synse.Plugin/Devices", opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginDevicesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Plugin_DevicesClient interface {
	Recv() (*Device, error)
	grpc.ClientStream
}

type pluginDevicesClient struct {
	grpc.ClientStream
}

func (x *pluginDevicesClient) Recv() (*Device, error) {
	m := new(Device)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pluginClient) Read(ctx context.Context, in *DeviceFilter, opts ...grpc.CallOption) (Plugin_ReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Plugin_serviceDesc.Streams[2], c.cc, "/synse.Plugin/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Plugin_ReadClient interface {
	Recv() (*Reading, error)
	grpc.ClientStream
}

type pluginReadClient struct {
	grpc.ClientStream
}

func (x *pluginReadClient) Recv() (*Reading, error) {
	m := new(Reading)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pluginClient) ReadCached(ctx context.Context, in *Bounds, opts ...grpc.CallOption) (Plugin_ReadCachedClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Plugin_serviceDesc.Streams[3], c.cc, "/synse.Plugin/ReadCached", opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginReadCachedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Plugin_ReadCachedClient interface {
	Recv() (*DeviceReading, error)
	grpc.ClientStream
}

type pluginReadCachedClient struct {
	grpc.ClientStream
}

func (x *pluginReadCachedClient) Recv() (*DeviceReading, error) {
	m := new(DeviceReading)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pluginClient) Write(ctx context.Context, in *WriteInfo, opts ...grpc.CallOption) (*Transactions, error) {
	out := new(Transactions)
	err := grpc.Invoke(ctx, "/synse.Plugin/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Transaction(ctx context.Context, in *TransactionFilter, opts ...grpc.CallOption) (Plugin_TransactionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Plugin_serviceDesc.Streams[4], c.cc, "/synse.Plugin/Transaction", opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginTransactionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Plugin_TransactionClient interface {
	Recv() (*WriteResponse, error)
	grpc.ClientStream
}

type pluginTransactionClient struct {
	grpc.ClientStream
}

func (x *pluginTransactionClient) Recv() (*WriteResponse, error) {
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Plugin service

type PluginServer interface {
	// Test returns the status of the plugin. This call is intended to
	// be used in order to check if a plugin is reachable. The status
	// returned here designates plugin reachability, not plugin health.
	Test(context.Context, *Empty) (*Status, error)
	// Version returns the version info for the plugin. This is not used
	// by Synse Server, but can be used by the CLI/manual plugin interaction.
	Version(context.Context, *Empty) (*VersionInfo, error)
	// Health returns the health status of a plugin.
	Health(context.Context, *Empty) (*PluginHealth, error)
	// Metainfo gets the metainfo for the plugin. This info provides details
	// about the plugin itself.
	Metainfo(context.Context, *Empty) (*Metadata, error)
	// Capabilities returns the collection of capabilities that a plugin
	// exposes. More specifically, this means types of devices supported
	// and the readings supported for each of those devices.
	Capabilities(*Empty, Plugin_CapabilitiesServer) error
	// Devices gets info for all of the devices that the plugin manages.
	// This rpc call is the plugin's equivalent to a Synse Server scan.
	Devices(*DeviceFilter, Plugin_DevicesServer) error
	// Read returns the reading data for the specified device.
	Read(*DeviceFilter, Plugin_ReadServer) error
	// ReadCached returns the reading data that is cached by the plugin.
	// If caching is not enabled on the plugin, this will just return the
	// current readings.
	ReadCached(*Bounds, Plugin_ReadCachedServer) error
	// Write issues an asynchronous write command to the specified device.
	Write(context.Context, *WriteInfo) (*Transactions, error)
	// Transactiong gets the state/status of an asynchronous write transaction.
	Transaction(*TransactionFilter, Plugin_TransactionServer) error
}

func RegisterPluginServer(s *grpc.Server, srv PluginServer) {
	s.RegisterService(&_Plugin_serviceDesc, srv)
}

func _Plugin_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synse.Plugin/Test",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Test(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synse.Plugin/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synse.Plugin/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Health(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Metainfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Metainfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synse.Plugin/Metainfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Metainfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Capabilities_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PluginServer).Capabilities(m, &pluginCapabilitiesServer{stream})
}

type Plugin_CapabilitiesServer interface {
	Send(*DeviceCapability) error
	grpc.ServerStream
}

type pluginCapabilitiesServer struct {
	grpc.ServerStream
}

func (x *pluginCapabilitiesServer) Send(m *DeviceCapability) error {
	return x.ServerStream.SendMsg(m)
}

func _Plugin_Devices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PluginServer).Devices(m, &pluginDevicesServer{stream})
}

type Plugin_DevicesServer interface {
	Send(*Device) error
	grpc.ServerStream
}

type pluginDevicesServer struct {
	grpc.ServerStream
}

func (x *pluginDevicesServer) Send(m *Device) error {
	return x.ServerStream.SendMsg(m)
}

func _Plugin_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PluginServer).Read(m, &pluginReadServer{stream})
}

type Plugin_ReadServer interface {
	Send(*Reading) error
	grpc.ServerStream
}

type pluginReadServer struct {
	grpc.ServerStream
}

func (x *pluginReadServer) Send(m *Reading) error {
	return x.ServerStream.SendMsg(m)
}

func _Plugin_ReadCached_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Bounds)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PluginServer).ReadCached(m, &pluginReadCachedServer{stream})
}

type Plugin_ReadCachedServer interface {
	Send(*DeviceReading) error
	grpc.ServerStream
}

type pluginReadCachedServer struct {
	grpc.ServerStream
}

func (x *pluginReadCachedServer) Send(m *DeviceReading) error {
	return x.ServerStream.SendMsg(m)
}

func _Plugin_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synse.Plugin/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Write(ctx, req.(*WriteInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Transaction_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TransactionFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PluginServer).Transaction(m, &pluginTransactionServer{stream})
}

type Plugin_TransactionServer interface {
	Send(*WriteResponse) error
	grpc.ServerStream
}

type pluginTransactionServer struct {
	grpc.ServerStream
}

func (x *pluginTransactionServer) Send(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Plugin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "synse.Plugin",
	HandlerType: (*PluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Test",
			Handler:    _Plugin_Test_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _Plugin_Version_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _Plugin_Health_Handler,
		},
		{
			MethodName: "Metainfo",
			Handler:    _Plugin_Metainfo_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _Plugin_Write_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Capabilities",
			Handler:       _Plugin_Capabilities_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Devices",
			Handler:       _Plugin_Devices_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Read",
			Handler:       _Plugin_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReadCached",
			Handler:       _Plugin_ReadCached_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Transaction",
			Handler:       _Plugin_Transaction_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "synse.proto",
}

func init() { proto.RegisterFile("synse.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x57, 0xdd, 0x6e, 0x1b, 0xc5,
	0x17, 0xf7, 0xda, 0xeb, 0xb5, 0x7d, 0xd6, 0xce, 0xdf, 0xff, 0x69, 0x54, 0xac, 0x50, 0x11, 0xb3,
	0x6d, 0x90, 0xc5, 0x47, 0x28, 0xee, 0x27, 0x20, 0x21, 0xd2, 0x38, 0x6d, 0xa2, 0x86, 0x24, 0x0c,
	0x69, 0x2b, 0xae, 0xaa, 0xc9, 0xee, 0xd4, 0x19, 0x62, 0xef, 0x5a, 0x3b, 0xe3, 0x48, 0x16, 0xd7,
	0x3c, 0x02, 0x0f, 0xc0, 0x3d, 0x57, 0xbc, 0x00, 0xdc, 0x73, 0xc3, 0x43, 0xf0, 0x20, 0x68, 0x66,
	0xce, 0xae, 0x77, 0x83, 0xa1, 0x08, 0xee, 0xf6, 0xfc, 0xe6, 0x77, 0xe6, 0x7c, 0xcc, 0x99, 0x73,
	0x66, 0xc1, 0x97, 0x8b, 0x58, 0xf2, 0xed, 0x59, 0x9a, 0xa8, 0x84, 0xd4, 0x8d, 0x10, 0xdc, 0x06,
	0xef, 0x51, 0x32, 0x8f, 0x23, 0x49, 0xd6, 0xa1, 0x2e, 0x15, 0x4b, 0x55, 0xcf, 0xe9, 0x3b, 0x83,
	0x16, 0xb5, 0x02, 0xe9, 0x42, 0x8d, 0xc7, 0x51, 0xaf, 0x6a, 0x30, 0xfd, 0x19, 0x9c, 0x40, 0x7b,
	0xc4, 0x2f, 0x45, 0xc8, 0x1f, 0x8b, 0x89, 0xe2, 0x29, 0x21, 0xe0, 0xa6, 0x2c, 0xbc, 0x40, 0x35,
	0xf3, 0xad, 0xf7, 0x3a, 0x4b, 0x58, 0x9a, 0xe9, 0x59, 0x81, 0x5c, 0x07, 0x2f, 0x32, 0x9a, 0xbd,
	0x9a, 0x81, 0x51, 0x0a, 0x1a, 0x50, 0xdf, 0x9b, 0xce, 0xd4, 0x22, 0xe8, 0x81, 0xf7, 0x95, 0x62,
	0x6a, 0x2e, 0xc9, 0x1a, 0x54, 0x13, 0xbb, 0x65, 0x93, 0x56, 0x93, 0x8b, 0xe0, 0x37, 0x07, 0xda,
	0x27, 0x93, 0xf9, 0x58, 0xc4, 0xfb, 0x9c, 0x4d, 0xd4, 0x39, 0xb9, 0x01, 0x2d, 0x25, 0xa6, 0x5c,
	0x2a, 0x36, 0x9d, 0xa1, 0xe9, 0x25, 0x40, 0x86, 0xe0, 0x49, 0xb3, 0x91, 0x71, 0x60, 0x6d, 0xb8,
	0xb1, 0x6d, 0x43, 0x2f, 0x6e, 0xb1, 0x6d, 0x4d, 0x51, 0x64, 0x92, 0x77, 0xc1, 0x0b, 0xcf, 0x79,
	0x78, 0x21, 0x7b, 0xb5, 0x7e, 0x6d, 0xe0, 0x0f, 0x09, 0xea, 0x58, 0xf6, 0xae, 0x5e, 0xa2, 0xc8,
	0x08, 0x1e, 0xe5, 0x8e, 0xfa, 0xd0, 0x78, 0x76, 0xf4, 0xf4, 0xe8, 0xf8, 0xc5, 0x51, 0xb7, 0x42,
	0x3c, 0xa8, 0x1e, 0x3f, 0xed, 0x3a, 0xe4, 0x3a, 0x90, 0x93, 0x1d, 0x7a, 0x7a, 0xb0, 0x73, 0x78,
	0xf8, 0xf5, 0xcb, 0xd1, 0xde, 0x13, 0xba, 0x33, 0xda, 0x1b, 0x75, 0x6b, 0x9a, 0xfc, 0x78, 0xe7,
	0xe0, 0xf0, 0xe0, 0xe8, 0x49, 0xd7, 0x0d, 0x7e, 0x70, 0xc0, 0x2f, 0xec, 0xad, 0xf3, 0x18, 0xb3,
	0x29, 0xcf, 0xf2, 0xa8, 0xbf, 0xff, 0x55, 0x1c, 0x3d, 0x68, 0x4c, 0xb9, 0x94, 0x6c, 0x9c, 0xa5,
	0x39, 0x13, 0xcb, 0x39, 0x73, 0xaf, 0xe6, 0x8c, 0x80, 0xab, 0x16, 0x33, 0xde, 0xab, 0x5b, 0xfb,
	0xfa, 0x3b, 0xf8, 0x1c, 0xba, 0xf6, 0xac, 0x77, 0xd9, 0x8c, 0x9d, 0x89, 0x89, 0x50, 0x0b, 0xcd,
	0xbb, 0x10, 0x71, 0x94, 0xf9, 0xa9, 0xbf, 0xb5, 0xcd, 0x64, 0xae, 0x66, 0x73, 0xa5, 0x1d, 0xad,
	0x69, 0x9b, 0x28, 0x06, 0x3f, 0x39, 0xd0, 0xfc, 0x82, 0x2b, 0x16, 0x31, 0xc5, 0x56, 0x86, 0xf8,
	0x16, 0xc0, 0x94, 0x89, 0x58, 0x31, 0x11, 0xf3, 0x14, 0xeb, 0xa5, 0x80, 0xe8, 0x02, 0x54, 0x6c,
	0x8c, 0xa1, 0xe8, 0x4f, 0xd2, 0x07, 0x3f, 0xe2, 0x32, 0x4c, 0xc5, 0x4c, 0x89, 0x24, 0xc6, 0x40,
	0x8a, 0x90, 0xd6, 0xb9, 0x0c, 0x25, 0x46, 0xa2, 0x3f, 0xc9, 0xfb, 0xd0, 0xb8, 0xe4, 0xa9, 0xd4,
	0x7c, 0xaf, 0xef, 0x14, 0x4e, 0xf7, 0xb9, 0x45, 0x0f, 0xe2, 0x57, 0x09, 0xcd, 0x28, 0xc1, 0xaf,
	0x0e, 0xf8, 0x85, 0x05, 0x72, 0x0b, 0x3a, 0x33, 0x93, 0x71, 0x04, 0x31, 0x80, 0x32, 0xa8, 0x23,
	0x91, 0xd1, 0x45, 0x46, 0xc1, 0x48, 0x96, 0x88, 0x4e, 0xff, 0xd9, 0x5c, 0x4c, 0xa2, 0x11, 0x53,
	0xd9, 0xd1, 0x2c, 0x01, 0xbd, 0x3a, 0x16, 0x6a, 0x37, 0x99, 0x4e, 0x85, 0xca, 0x0e, 0x27, 0x07,
	0xf4, 0xd5, 0x19, 0x0b, 0x75, 0xca, 0xc6, 0x18, 0x14, 0x4a, 0x3a, 0xa3, 0x2c, 0x0d, 0xcf, 0x4d,
	0x50, 0x2d, 0x6a, 0xbe, 0xcd, 0xdd, 0x91, 0xbd, 0x86, 0x41, 0xaa, 0x89, 0x0c, 0x7e, 0xa9, 0x41,
	0x83, 0x72, 0x16, 0x89, 0x78, 0xfc, 0x9a, 0x6b, 0x93, 0x95, 0x40, 0x75, 0x59, 0x02, 0x1a, 0x13,
	0xf1, 0xab, 0x04, 0x1d, 0x36, 0xdf, 0x64, 0x13, 0xdc, 0x79, 0x8c, 0x6e, 0xfa, 0x43, 0x1f, 0x53,
	0xf9, 0x2c, 0x16, 0x8a, 0x9a, 0x05, 0x72, 0x13, 0xda, 0x52, 0xa5, 0x22, 0x1e, 0xbf, 0xbc, 0x64,
	0x93, 0x39, 0xd6, 0xd4, 0x7e, 0x85, 0xfa, 0x16, 0x7d, 0xae, 0x41, 0xb2, 0x09, 0x70, 0x96, 0x24,
	0x13, 0xa4, 0xe8, 0x08, 0x9a, 0xfb, 0x15, 0xda, 0xd2, 0x98, 0x25, 0x6c, 0x41, 0xe7, 0xd5, 0x24,
	0x61, 0xea, 0xce, 0x10, 0x39, 0x3a, 0xa6, 0xea, 0x7e, 0x85, 0xb6, 0x11, 0x2e, 0xd3, 0xee, 0xdf,
	0x45, 0x5a, 0xb3, 0xef, 0x0c, 0x9c, 0x9c, 0x76, 0xff, 0xae, 0xa5, 0xbd, 0x0d, 0xbe, 0x88, 0x97,
	0x7b, 0xb5, 0xfa, 0xce, 0xa0, 0xbe, 0x5f, 0xa1, 0x60, 0xc0, 0x22, 0x25, 0xdf, 0x07, 0xfa, 0xce,
	0xa0, 0x86, 0x94, 0xc2, 0x2e, 0x67, 0x0b, 0xc5, 0x25, 0x52, 0xfc, 0xbe, 0x33, 0x68, 0x6b, 0x8a,
	0x01, 0x2d, 0xe5, 0x26, 0xb4, 0xe7, 0x45, 0x4b, 0xed, 0xbe, 0x33, 0xe8, 0xe8, 0xe0, 0xe7, 0x05,
	0x53, 0x48, 0xca, 0x6d, 0x75, 0xfa, 0xce, 0xc0, 0xcd, 0x48, 0x68, 0xec, 0x51, 0x03, 0xea, 0x66,
	0x35, 0xf8, 0x16, 0x3a, 0xf6, 0x1e, 0x66, 0xe7, 0xf8, 0x9f, 0x9b, 0x2e, 0x19, 0x40, 0x23, 0xb5,
	0x9b, 0xe1, 0x31, 0xae, 0xe1, 0x31, 0xa2, 0x09, 0x9a, 0x2d, 0x07, 0xdf, 0x40, 0xeb, 0x45, 0x2a,
	0x14, 0x37, 0x57, 0xe1, 0x01, 0xb4, 0xa3, 0x42, 0xf7, 0x37, 0x0e, 0xf8, 0xc3, 0x6b, 0xa8, 0x5b,
	0x1c, 0x0c, 0xb4, 0x44, 0x24, 0xb7, 0xc0, 0xd5, 0x3d, 0xc0, 0xf4, 0x07, 0x7f, 0xd8, 0x45, 0x05,
	0xb3, 0xf1, 0x88, 0x29, 0x46, 0xcd, 0x6a, 0xf0, 0x00, 0x6d, 0x69, 0x48, 0xbb, 0xce, 0x42, 0xb5,
	0xbc, 0x6f, 0x28, 0xe9, 0xe0, 0x71, 0x2b, 0x67, 0xd0, 0x46, 0xc5, 0x9f, 0xab, 0xd0, 0x31, 0x9a,
	0x94, 0xcb, 0x59, 0x12, 0x4b, 0xae, 0xaf, 0x81, 0xc8, 0xba, 0x54, 0x55, 0x98, 0x1e, 0x15, 0xa6,
	0x9c, 0x29, 0x9e, 0x25, 0x28, 0x13, 0xf5, 0xca, 0x7c, 0x16, 0x99, 0x15, 0xec, 0x98, 0x28, 0x92,
	0x87, 0x79, 0xff, 0x75, 0x4d, 0xff, 0xed, 0x17, 0xdd, 0xce, 0x2c, 0x59, 0xe9, 0x4a, 0x17, 0xbe,
	0x67, 0xa6, 0xa9, 0xb2, 0xa5, 0xbf, 0x36, 0xdc, 0xfc, 0x7b, 0x45, 0x4e, 0x2d, 0xbb, 0xd8, 0xbc,
	0xbd, 0x52, 0xf3, 0x0e, 0x3e, 0x03, 0xbf, 0x60, 0xa7, 0x3c, 0x77, 0x7c, 0x68, 0x9c, 0xec, 0x1d,
	0x8d, 0xf4, 0x5c, 0x71, 0xb4, 0xf0, 0x82, 0x1e, 0x9c, 0x6a, 0xa1, 0x4a, 0x9a, 0xe0, 0x8e, 0x8e,
	0x8f, 0xf6, 0xba, 0xb5, 0x60, 0x13, 0x60, 0x69, 0x0e, 0x27, 0x55, 0x85, 0xb4, 0xa0, 0xbe, 0x47,
	0xe9, 0x31, 0xed, 0x3a, 0xc1, 0x4d, 0xf8, 0xff, 0x69, 0xca, 0x62, 0x69, 0x93, 0x8c, 0xa7, 0x76,
	0x25, 0x89, 0xc1, 0x8f, 0x0e, 0xb4, 0x0b, 0x2c, 0x49, 0x0e, 0xa0, 0xad, 0x0a, 0x72, 0xcf, 0x31,
	0xc7, 0xbb, 0x85, 0xe1, 0x16, 0xa9, 0x25, 0x61, 0x2f, 0x56, 0xe9, 0x82, 0x96, 0x54, 0x37, 0xbe,
	0x2c, 0x39, 0x60, 0x29, 0xba, 0x95, 0x5f, 0xf0, 0x05, 0x7a, 0xa0, 0x3f, 0xc9, 0x3b, 0x78, 0x29,
	0xcc, 0x29, 0xae, 0xaa, 0x24, 0xbb, 0xfc, 0x49, 0xf5, 0xa1, 0x13, 0xfc, 0x5e, 0x05, 0xcf, 0xd6,
	0xe4, 0x6b, 0x3a, 0x5f, 0x17, 0x6a, 0x73, 0x91, 0x3f, 0x73, 0xe6, 0x22, 0xca, 0xc7, 0x5c, 0xad,
	0x30, 0xe6, 0x1e, 0x40, 0x73, 0x8a, 0xb3, 0xac, 0xe7, 0x9a, 0x40, 0xdf, 0x2c, 0x15, 0xfe, 0x76,
	0x36, 0xe9, 0x6c, 0x78, 0x39, 0x59, 0x57, 0xb2, 0x9d, 0x15, 0x59, 0xfb, 0xb6, 0x52, 0xde, 0x5c,
	0xbd, 0x42, 0x73, 0x7d, 0x0f, 0x9a, 0x93, 0x24, 0x64, 0xa6, 0xee, 0x1b, 0x26, 0xc4, 0xff, 0xa1,
	0x91, 0x43, 0x84, 0x69, 0x4e, 0xd0, 0xb3, 0x50, 0x26, 0xa9, 0x3a, 0x4e, 0x23, 0x11, 0xb3, 0x89,
	0xe9, 0x7c, 0x75, 0x5a, 0x84, 0xc8, 0x16, 0x78, 0x76, 0x16, 0xf7, 0x5a, 0xc6, 0xe3, 0x0e, 0x6e,
	0x76, 0x6c, 0x40, 0x8a, 0x8b, 0x1b, 0x9f, 0x42, 0xa7, 0xe4, 0xfc, 0x8a, 0xc4, 0xaf, 0x17, 0x13,
	0xdf, 0x2a, 0xa6, 0xf9, 0x2e, 0x34, 0x33, 0xdf, 0xfe, 0x79, 0x67, 0x0a, 0xbe, 0x77, 0xc0, 0xb3,
	0x5e, 0xac, 0x7c, 0x18, 0xac, 0x1a, 0x46, 0x37, 0xa0, 0x35, 0x4b, 0x79, 0x28, 0xcc, 0x84, 0xad,
	0x99, 0x60, 0x97, 0x80, 0x1e, 0xd3, 0x32, 0x64, 0x13, 0x11, 0x8f, 0x1f, 0xb3, 0x50, 0x25, 0xa9,
	0xb9, 0xb4, 0x0e, 0x2d, 0x83, 0xf9, 0xf0, 0xaa, 0xff, 0xc5, 0xf0, 0x0a, 0x86, 0xe0, 0x6a, 0x69,
	0xa5, 0x53, 0xd7, 0xc1, 0x93, 0x8b, 0xe9, 0x59, 0x32, 0x41, 0xb7, 0x50, 0x1a, 0x7e, 0xe7, 0x82,
	0x67, 0x1f, 0x65, 0x64, 0x0b, 0xdc, 0x53, 0x2e, 0x15, 0x69, 0xe3, 0xce, 0xe6, 0x69, 0xbb, 0x91,
	0xa5, 0xdd, 0x5e, 0xdf, 0xa0, 0x42, 0x3e, 0x80, 0x46, 0xf6, 0x30, 0x28, 0x33, 0x57, 0xbc, 0x4c,
	0x0c, 0xdd, 0xc3, 0x97, 0x6f, 0x99, 0x7d, 0x6d, 0xc5, 0x8b, 0x30, 0xa8, 0xe8, 0x22, 0xd2, 0xc7,
	0x69, 0x0a, 0xaa, 0xac, 0x90, 0x15, 0x53, 0x76, 0xda, 0x41, 0x85, 0x7c, 0x0c, 0xed, 0xfc, 0x7d,
	0x27, 0xb8, 0xbc, 0xa2, 0xf0, 0x46, 0xa9, 0xc4, 0x97, 0x0f, 0xc1, 0xa0, 0x72, 0xdb, 0x21, 0x1f,
	0x41, 0xc3, 0xe2, 0x92, 0xac, 0x9a, 0x01, 0x79, 0xd8, 0x16, 0x34, 0x2a, 0x1f, 0x82, 0xab, 0x47,
	0xcc, 0x6a, 0xfe, 0x95, 0x21, 0x64, 0x14, 0xee, 0x01, 0x68, 0x71, 0x97, 0x85, 0xe7, 0x3c, 0x22,
	0xd9, 0x8e, 0xf6, 0xaf, 0x65, 0x63, 0xbd, 0xb4, 0x4b, 0x51, 0xed, 0x36, 0xd4, 0x4d, 0x4f, 0x20,
	0xa5, 0x0e, 0xa1, 0xd3, 0x99, 0x27, 0xad, 0xd8, 0x6e, 0x82, 0x0a, 0xd9, 0x01, 0xbf, 0x80, 0x90,
	0xde, 0x9f, 0x59, 0xe8, 0xe5, 0xfa, 0xaa, 0x6e, 0xae, 0x8d, 0x9e, 0x79, 0xe6, 0xe7, 0xea, 0xce,
	0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4e, 0xac, 0xc9, 0x36, 0x6b, 0x0d, 0x00, 0x00,
}
